# 本題解題沒什麼頭緒。 1100..0 可變 0100..0， 110可變010
# 規則1: 1 <-> 0
# 規則2: 1100...0 <-> 100...0 少一位
# 看 lee215 的解法，程式很短，想法就拆解，利用11000 當 helper。
# 1xxxx -> 11000 -> 01000 -> 0 也就是位數會越來越短
# n原本數   helper  少1位的數  最後變0
#    需要步數    需要1步   需要2^k-1步
class Solution:
    dp = {0: 0} # global 的字典，用來快速找到答案
    def minimumOneBitOperations(self, n: int) -> int:
        if n not in self.dp: # 如果還沒有找到答案，就再函式呼叫函式
            b = 1 # 想要找到「不超過n的最大的2^k」的數，先從1開始試
            while (b << 1) <= n: # 若進位後，還沒超過
                b = b << 1 # 就真的進位，變更大的數
            # 離開迴圈時， b便是「不超過n的最大的2^k」的數
            helper = b + (b//2) # 110...00 這個數
            part1 = self.minimumOneBitOperations(helper ^ n) + 1
            # 把 1xx..xx 變成 helper 110..00, 再1步變成 10..00
            part2 = b - 1 # 可以把 10..00 變成 0 的操作次數 2^k-1 步
            self.dp[n] = part1 + part2
        return self.dp[n]

# 試著從 0 開始長大
# 0, 
# 1, 
# 11, 10, 
# 110, 111, 101, 100, 
# 1100, 1101, 1111, 1110, 1010, 1011, 1001, 1000
# 11000,11001,11011,11010,11110,11111,11101,11100,10100,10101,10111,10110,10010,10011,10001,10000,
# 110000,...
# 好像有某種規則，要走 2^k-1 步，便能到達 2^k

// LeetCode 3075. Maximize Happiness of Selected Children
// 挑選快樂的小朋友很開心。不過挑了一位小朋友後，還沒被挑到的小朋友就漸漸不開心了
// 一次只能挑一位，要請問怎麼挑，可以得到最高的「快樂分數」
// 其實照著排序，再依序從高到低挑，就可以知道答案了，快樂值降到0就停下來。簡單。
// 只是在挑的時候，有 2*10^5 個人要挑，數量有點多，要能提早離開迴圈。
// 另外如果要挑的人比較少，不用 sort 而改用 priority queue 會更快。
int cmp(const void* p1, const void* p2) {
    return *(int*)p2 - *(int*)p1;
}
long long maximumHappinessSum(int* happiness, int happinessSize, int k) {
    qsort(happiness, happinessSize, sizeof(int), cmp);
    long long int ans = 0;
    for(int i=0; i<k; i++) {
        if(happiness[i]>i) ans += happiness[i] - i;
        else break;
    }
    return ans;
}

// case 643/674: [2135218,73431904,92495076,77528042,82824634,3036629,28375907,65220365,40948869,58914871,57169530,89783499,19582915,19676695,11932465,21770144,49740276,22303751,80746555,97391584,95775653,43396943,47271136,43935930,59643137,64183008,8892641,39587569,85086654,5663585,82925096,24868817,95900395,48155864,74447380,7618448,63299623,91141186,33347112,81951555,52867615,92184410,7024265,85525916,29846922,59532692,47267934,6514603,1137830,97807470]
// 數字超大, 加起來會超過 int 的範圍, 要用 long long int

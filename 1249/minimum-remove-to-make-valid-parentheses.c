// 有一堆括號和英文字母，但可能不是「合理的括號配對」。
// 問「刪掉幾個括號」後，便能合理
// 最誇張的狀況，是括號全刪。但若能組出合法配對，其實就不用刪
char* minRemoveToMakeValid(char* s) {
    int stack[100000], stackN = 0; // 用來存 括號的位置
    for (int i=0; s[i]!=0; i++) { // 字串的迴圈
        if (s[i]=='(') { // 上括號，放入 stack 
            stack[stackN++] = i; // 記下位置i
        } else if (s[i]==')') { // 下括號，可能成功、可能失敗
            if (stackN>0) { // 括號配對完成，安全下崗，不需處理
                stackN--; // 順利退回一組
            } else { // 不能正確配對/括號對不起來，失敗
                s[i] = '-'; // 標示- 之後要避開
            }
        }
    }
    // 離開字串迴圈後，看 stack 裡還有多少要清空
    for (int i=0; i<stackN; i++){
        s[stack[i]] = '-'; // 標示- 之後要避開
    } // 最後收尾時，沒配對到的上括號，都要清空
    // 最後，避開所有 '-' 的部分
    int k = 0; //放答案的位置
    for (int i=0; s[i]!=0; i++){ // 針對 s 裡的每個字母
        if (s[i]!='-') { // 沒有被清空，就 copy 它
            s[k++] = s[i]; // 搬過去，並換下一格待命
        }
    }
    s[k] = 0;
    return s;
}

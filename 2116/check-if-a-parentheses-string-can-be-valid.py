# LeetCode 2116. Check if a Parentheses String Can Be Valid
# s 裡有很多括號，locked會鎖住某些括號/不能改變，問能不能變成正確的括號組合
class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        if len(s) % 2 != 0: return False  # 奇數個括號，一定失敗
        d1 = d2 = 0  # d1是括號depth層數的上界，d2是下界，最後需要「包含0」
        # d1...d2 兩者「差」是運作時的容忍範圍
        for i in range(len(s)):
            if locked[i]=='1': # 不能改
                if s[i]=='(': # 不能改的上括號
                    d1 += 1 # 括號的層數增加
                    d2 += 1
                if s[i]==')': # 不能改的下括號
                    d1 -= 1 # 括號的層數減少
                    d2 -= 1
            else: # 這格可以改，括號的層數能增加、也能減少（容忍的範圍變大了）
                d1 += 1 # 上界增加
                d2 -= 1 # 下界減少
            if d1<0: return False # 括號上界扣到變負，代表括號層數在過程中變負的，沒救了
            if d2<0: d2 = 0 # 將層數下界調為0，保持合理的「上下界」（負的層數不合理，被去除掉）
        # print(d1,d2)
        # 最後結束時，層數必須要剛好為0才行
        return d2==0  # 必須是0
# case 72/258: s = "())(()(()(())()())(())((())(()())((())))))(((((((())(()))))("
# locked = "100011110110011011010111100111011101111110000101001101001111"
